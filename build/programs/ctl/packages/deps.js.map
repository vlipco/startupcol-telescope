{"version":3,"file":"/packages/deps.js","sources":["deps/deps.js","deps/deprecated.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,kD;AACA,kD;AACA,kD;;AAEA,U;;AAEA,sC;AACA,oB;;AAEA,kD;AACA,+B;;AAEA,0C;AACA,8B;AACA,qB;AACA,E;;AAEA,8B;AACA,+D;AACA,yD;AACA,4D;AACA,mE;AACA,4B;AACA,E;;AAEA,sC;AACA,wB;AACA,Y;AACA,U;AACA,8D;AACA,uC;AACA,G;AACA,E;;AAEA,oE;AACA,oE;AACA,0D;AACA,kE;AACA,uB;AACA,wC;AACA,2D;AACA,a;AACA,U;AACA,wB;AACA,2B;AACA,2C;AACA,4B;AACA,S;AACA,M;AACA,G;AACA,E;;AAEA,e;AACA,4D;AACA,6B;AACA,sE;AACA,sB;AACA,qC;AACA,oB;AACA,kE;AACA,+D;AACA,kE;AACA,iD;AACA,sB;AACA,oE;AACA,oE;AACA,qE;AACA,iE;AACA,U;AACA,4B;;AAEA,6B;;AAEA,gC;AACA,oB;AACA,8B;AACA,qB;AACA,G;AACA,E;;AAEA,sD;AACA,0C;AACA,oC;;AAEA,E;AACA,2C;AACA,E;AACA,yC;AACA,gC;AACA,oB;AACA,mE;AACA,kC;;AAEA,kB;;AAEA,gD;AACA,uB;;AAEA,oD;AACA,2B;;AAEA,iD;AACA,uB;;AAEA,sB;AACA,mC;AACA,yD;AACA,2D;AACA,wB;AACA,iB;AACA,4B;;AAEA,qB;AACA,O;AACA,oB;AACA,oB;AACA,a;AACA,0B;AACA,gB;AACA,kB;AACA,G;AACA,E;;AAEA,mD;AACA,wD;AACA,kB;;AAEA,8B;AACA,wD;;AAEA,yB;AACA,kC;AACA,mC;AACA,O;AACA,U;AACA,wC;AACA,G;AACA,E;;AAEA,iD;AACA,qD;AACA,kB;AACA,2B;AACA,wD;AACA,uD;AACA,gD;AACA,qB;AACA,qC;AACA,K;;AAEA,4B;;AAEA,6C;AACA,iC;AACA,gE;AACA,oC;AACA,qC;AACA,S;AACA,K;AACA,qC;AACA,G;AACA,E;;AAEA,2C;AACA,+C;AACA,uB;AACA,wB;AACA,sB;AACA,G;AACA,E;;AAEA,mD;AACA,kB;AACA,2B;;AAEA,yC;AACA,8B;AACA,oC;AACA,mB;AACA,O;AACA,0C;AACA,a;AACA,oC;AACA,sB;AACA,G;AACA,E;;AAEA,qD;AACA,kB;;AAEA,2B;AACA,O;AACA,gD;AACA,W;AACA,wB;AACA,mB;AACA,oC;AACA,O;AACA,gE;AACA,iE;AACA,kC;AACA,Q;AACA,kE;AACA,e;AACA,K;AACA,a;AACA,8B;AACA,G;AACA,E;;AAEA,E;AACA,0C;AACA,E;AACA,+B;AACA,4B;AACA,E;;AAEA,4C;AACA,E;AACA,sD;AACA,sE;AACA,kE;AACA,qC;AACA,2D;AACA,sB;AACA,sB;AACA,mB;;AAEA,0C;AACA,G;AACA,kB;AACA,2B;AACA,uC;AACA,2C;AACA,0C;AACA,sC;AACA,O;AACA,gB;AACA,G;AACA,e;AACA,E;;AAEA,6C;AACA,iD;AACA,kB;AACA,sC;AACA,0C;AACA,E;;AAEA,mD;AACA,uD;AACA,kB;AACA,qC;AACA,gB;AACA,e;AACA,E;;AAEA,qC;AACA,+B;AACA,oE;AACA,gB;AACA,I;AACA,gE;AACA,6D;AACA,4D;AACA,4D;AACA,+D;AACA,yC;AACA,I;AACA,sD;AACA,c;AACA,4D;;AAEA,gB;AACA,uD;;AAEA,iB;AACA,mB;AACA,yD;;AAEA,0B;AACA,O;AACA,wC;AACA,wC;;AAEA,2C;AACA,0C;AACA,+C;AACA,0B;AACA,O;;AAEA,uC;AACA,kD;AACA,uC;AACA,+C;AACA,a;AACA,iB;AACA,qB;AACA,gD;AACA,S;AACA,O;AACA,K;AACA,uB;AACA,a;AACA,wB;AACA,uB;AACA,oE;AACA,+D;AACA,K;AACA,sB;AACA,oB;AACA,G;AACA,E;;AAEA,uC;AACA,E;AACA,0D;AACA,uB;AACA,E;AACA,wD;AACA,E;AACA,mD;AACA,mE;AACA,6B;AACA,8B;AACA,iE;;AAEA,iC;AACA,2D;;AAEA,kB;AACA,mC;AACA,e;AACA,O;;AAEA,W;AACA,E;;AAEA,2C;AACA,E;AACA,kE;AACA,gE;AACA,uE;AACA,kC;AACA,iC;AACA,yC;AACA,8B;AACA,O;AACA,e;AACA,a;AACA,oC;AACA,G;AACA,E;;AAEA,4C;AACA,kC;AACA,oB;AACA,uE;;AAEA,0C;AACA,E;;AAEA,0C;AACA,gC;AACA,8B;AACA,iB;AACA,E;;;;;;;;;;;;;;;;;;;AC9WA,wC;;AAEA,uE;AACA,gB;AACA,wB;AACA,0B;AACA,8B;;AAEA,+E;AACA,sC;AACA,wB;AACA,oC;;AAEA,mD;AACA,wB;AACA,4B;AACA,oB;AACA,E","sourcesContent":["//////////////////////////////////////////////////\n// Package docs at http://docs.meteor.com/#deps //\n//////////////////////////////////////////////////\n\nDeps = {};\n\n// http://docs.meteor.com/#deps_active\nDeps.active = false;\n\n// http://docs.meteor.com/#deps_currentcomputation\nDeps.currentComputation = null;\n\nvar setCurrentComputation = function (c) {\n  Deps.currentComputation = c;\n  Deps.active = !! c;\n};\n\nvar _debugFunc = function () {\n  // lazy evaluation because `Meteor` does not exist right away\n  return (typeof Meteor !== \"undefined\" ? Meteor._debug :\n          ((typeof console !== \"undefined\") && console.log ?\n           function () { console.log.apply(console, arguments); } :\n           function () {}));\n};\n\nvar _throwOrLog = function (from, e) {\n  if (throwFirstError) {\n    throw e;\n  } else {\n    _debugFunc()(\"Exception from Deps \" + from + \" function:\",\n                 e.stack || e.message);\n  }\n};\n\n// Takes a function `f`, and wraps it in a `Meteor._noYieldsAllowed`\n// block if we are running on the server. On the client, returns the\n// original function (since `Meteor._noYieldsAllowed` is a\n// no-op). This has the benefit of not adding an unnecessary stack\n// frame on the client.\nvar withNoYieldsAllowed = function (f) {\n  if ((typeof Meteor === 'undefined') || Meteor.isClient) {\n    return f;\n  } else {\n    return function () {\n      var args = arguments;\n      Meteor._noYieldsAllowed(function () {\n        f.apply(null, args);\n      });\n    };\n  }\n};\n\nvar nextId = 1;\n// computations whose callbacks we should call at flush time\nvar pendingComputations = [];\n// `true` if a Deps.flush is scheduled, or if we are in Deps.flush now\nvar willFlush = false;\n// `true` if we are in Deps.flush now\nvar inFlush = false;\n// `true` if we are computing a computation now, either first time\n// or recompute.  This matches Deps.active unless we are inside\n// Deps.nonreactive, which nullfies currentComputation even though\n// an enclosing computation may still be running.\nvar inCompute = false;\n// `true` if the `_throwFirstError` option was passed in to the call\n// to Deps.flush that we are in. When set, throw rather than log the\n// first error encountered while flushing. Before throwing the error,\n// finish flushing (from a finally block), logging any subsequent\n// errors.\nvar throwFirstError = false;\n\nvar afterFlushCallbacks = [];\n\nvar requireFlush = function () {\n  if (! willFlush) {\n    setTimeout(Deps.flush, 0);\n    willFlush = true;\n  }\n};\n\n// Deps.Computation constructor is visible but private\n// (throws an error if you try to call it)\nvar constructingComputation = false;\n\n//\n// http://docs.meteor.com/#deps_computation\n//\nDeps.Computation = function (f, parent) {\n  if (! constructingComputation)\n    throw new Error(\n      \"Deps.Computation constructor is private; use Deps.autorun\");\n  constructingComputation = false;\n\n  var self = this;\n\n  // http://docs.meteor.com/#computation_stopped\n  self.stopped = false;\n\n  // http://docs.meteor.com/#computation_invalidated\n  self.invalidated = false;\n\n  // http://docs.meteor.com/#computation_firstrun\n  self.firstRun = true;\n\n  self._id = nextId++;\n  self._onInvalidateCallbacks = [];\n  // the plan is at some point to use the parent relation\n  // to constrain the order that computations are processed\n  self._parent = parent;\n  self._func = f;\n  self._recomputing = false;\n\n  var errored = true;\n  try {\n    self._compute();\n    errored = false;\n  } finally {\n    self.firstRun = false;\n    if (errored)\n      self.stop();\n  }\n};\n\n// http://docs.meteor.com/#computation_oninvalidate\nDeps.Computation.prototype.onInvalidate = function (f) {\n  var self = this;\n\n  if (typeof f !== 'function')\n    throw new Error(\"onInvalidate requires a function\");\n\n  if (self.invalidated) {\n    Deps.nonreactive(function () {\n      withNoYieldsAllowed(f)(self);\n    });\n  } else {\n    self._onInvalidateCallbacks.push(f);\n  }\n};\n\n// http://docs.meteor.com/#computation_invalidate\nDeps.Computation.prototype.invalidate = function () {\n  var self = this;\n  if (! self.invalidated) {\n    // if we're currently in _recompute(), don't enqueue\n    // ourselves, since we'll rerun immediately anyway.\n    if (! self._recomputing && ! self.stopped) {\n      requireFlush();\n      pendingComputations.push(this);\n    }\n\n    self.invalidated = true;\n\n    // callbacks can't add callbacks, because\n    // self.invalidated === true.\n    for(var i = 0, f; f = self._onInvalidateCallbacks[i]; i++) {\n      Deps.nonreactive(function () {\n        withNoYieldsAllowed(f)(self);\n      });\n    }\n    self._onInvalidateCallbacks = [];\n  }\n};\n\n// http://docs.meteor.com/#computation_stop\nDeps.Computation.prototype.stop = function () {\n  if (! this.stopped) {\n    this.stopped = true;\n    this.invalidate();\n  }\n};\n\nDeps.Computation.prototype._compute = function () {\n  var self = this;\n  self.invalidated = false;\n\n  var previous = Deps.currentComputation;\n  setCurrentComputation(self);\n  var previousInCompute = inCompute;\n  inCompute = true;\n  try {\n    withNoYieldsAllowed(self._func)(self);\n  } finally {\n    setCurrentComputation(previous);\n    inCompute = false;\n  }\n};\n\nDeps.Computation.prototype._recompute = function () {\n  var self = this;\n\n  self._recomputing = true;\n  try {\n    while (self.invalidated && ! self.stopped) {\n      try {\n        self._compute();\n      } catch (e) {\n        _throwOrLog(\"recompute\", e);\n      }\n      // If _compute() invalidated us, we run again immediately.\n      // A computation that invalidates itself indefinitely is an\n      // infinite loop, of course.\n      //\n      // We could put an iteration counter here and catch run-away\n      // loops.\n    }\n  } finally {\n    self._recomputing = false;\n  }\n};\n\n//\n// http://docs.meteor.com/#deps_dependency\n//\nDeps.Dependency = function () {\n  this._dependentsById = {};\n};\n\n// http://docs.meteor.com/#dependency_depend\n//\n// Adds `computation` to this set if it is not already\n// present.  Returns true if `computation` is a new member of the set.\n// If no argument, defaults to currentComputation, or does nothing\n// if there is no currentComputation.\nDeps.Dependency.prototype.depend = function (computation) {\n  if (! computation) {\n    if (! Deps.active)\n      return false;\n\n    computation = Deps.currentComputation;\n  }\n  var self = this;\n  var id = computation._id;\n  if (! (id in self._dependentsById)) {\n    self._dependentsById[id] = computation;\n    computation.onInvalidate(function () {\n      delete self._dependentsById[id];\n    });\n    return true;\n  }\n  return false;\n};\n\n// http://docs.meteor.com/#dependency_changed\nDeps.Dependency.prototype.changed = function () {\n  var self = this;\n  for (var id in self._dependentsById)\n    self._dependentsById[id].invalidate();\n};\n\n// http://docs.meteor.com/#dependency_hasdependents\nDeps.Dependency.prototype.hasDependents = function () {\n  var self = this;\n  for(var id in self._dependentsById)\n    return true;\n  return false;\n};\n\n// http://docs.meteor.com/#deps_flush\nDeps.flush = function (_opts) {\n  // XXX What part of the comment below is still true? (We no longer\n  // have Spark)\n  //\n  // Nested flush could plausibly happen if, say, a flush causes\n  // DOM mutation, which causes a \"blur\" event, which runs an\n  // app event handler that calls Deps.flush.  At the moment\n  // Spark blocks event handlers during DOM mutation anyway,\n  // because the LiveRange tree isn't valid.  And we don't have\n  // any useful notion of a nested flush.\n  //\n  // https://app.asana.com/0/159908330244/385138233856\n  if (inFlush)\n    throw new Error(\"Can't call Deps.flush while flushing\");\n\n  if (inCompute)\n    throw new Error(\"Can't flush inside Deps.autorun\");\n\n  inFlush = true;\n  willFlush = true;\n  throwFirstError = !! (_opts && _opts._throwFirstError);\n\n  var finishedTry = false;\n  try {\n    while (pendingComputations.length ||\n           afterFlushCallbacks.length) {\n\n      // recompute all pending computations\n      while (pendingComputations.length) {\n        var comp = pendingComputations.shift();\n        comp._recompute();\n      }\n\n      if (afterFlushCallbacks.length) {\n        // call one afterFlush callback, which may\n        // invalidate more computations\n        var func = afterFlushCallbacks.shift();\n        try {\n          func();\n        } catch (e) {\n          _throwOrLog(\"afterFlush function\", e);\n        }\n      }\n    }\n    finishedTry = true;\n  } finally {\n    if (! finishedTry) {\n      // we're erroring\n      inFlush = false; // needed before calling `Deps.flush()` again\n      Deps.flush({_throwFirstError: false}); // finish flushing\n    }\n    willFlush = false;\n    inFlush = false;\n  }\n};\n\n// http://docs.meteor.com/#deps_autorun\n//\n// Run f(). Record its dependencies. Rerun it whenever the\n// dependencies change.\n//\n// Returns a new Computation, which is also passed to f.\n//\n// Links the computation to the current computation\n// so that it is stopped if the current computation is invalidated.\nDeps.autorun = function (f) {\n  if (typeof f !== 'function')\n    throw new Error('Deps.autorun requires a function argument');\n\n  constructingComputation = true;\n  var c = new Deps.Computation(f, Deps.currentComputation);\n\n  if (Deps.active)\n    Deps.onInvalidate(function () {\n      c.stop();\n    });\n\n  return c;\n};\n\n// http://docs.meteor.com/#deps_nonreactive\n//\n// Run `f` with no current computation, returning the return value\n// of `f`.  Used to turn off reactivity for the duration of `f`,\n// so that reactive data sources accessed by `f` will not result in any\n// computations being invalidated.\nDeps.nonreactive = function (f) {\n  var previous = Deps.currentComputation;\n  setCurrentComputation(null);\n  try {\n    return f();\n  } finally {\n    setCurrentComputation(previous);\n  }\n};\n\n// http://docs.meteor.com/#deps_oninvalidate\nDeps.onInvalidate = function (f) {\n  if (! Deps.active)\n    throw new Error(\"Deps.onInvalidate requires a currentComputation\");\n\n  Deps.currentComputation.onInvalidate(f);\n};\n\n// http://docs.meteor.com/#deps_afterflush\nDeps.afterFlush = function (f) {\n  afterFlushCallbacks.push(f);\n  requireFlush();\n};\n","// Deprecated (Deps-recated?) functions.\n\n// These functions used to be on the Meteor object (and worked slightly\n// differently).\n// XXX COMPAT WITH 0.5.7\nMeteor.flush = Deps.flush;\nMeteor.autorun = Deps.autorun;\n\n// We used to require a special \"autosubscribe\" call to reactively subscribe to\n// things. Now, it works with autorun.\n// XXX COMPAT WITH 0.5.4\nMeteor.autosubscribe = Deps.autorun;\n\n// This Deps API briefly existed in 0.5.8 and 0.5.9\n// XXX COMPAT WITH 0.5.9\nDeps.depend = function (d) {\n  return d.depend();\n};\n"]}