{"version":3,"file":"/packages/blaze.js","sources":["blaze/preamble.js","blaze/exceptions.js","blaze/reactivevar.js","blaze/view.js","blaze/builtins.js","blaze/lookup.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,W;;;;;;;;;;;;;;;;;;;ACAA,c;;AAEA,2E;AACA,8E;AACA,4E;AACA,sB;AACA,E;AACA,S;AACA,E;AACA,M;AACA,Q;AACA,yB;AACA,gB;AACA,0B;AACA,I;AACA,M;AACA,E;AACA,6D;;AAEA,yD;AACA,wD;AACA,iD;AACA,kC;;AAEA,2C;AACA,kC;AACA,sC;AACA,Y;AACA,G;;AAEA,kB;AACA,wB;AACA,6B;AACA,6D;AACA,8E;AACA,gC;AACA,M;;AAEA,4E;AACA,gF;AACA,gE;AACA,4E;AACA,E;;AAEA,oD;AACA,8B;AACA,a;;AAEA,sB;AACA,S;AACA,sC;AACA,iB;AACA,8D;AACA,K;AACA,I;AACA,E;;;;;;;;;;;;;;;;;;;ACvDA,G;AACA,yD;AACA,E;AACA,8D;AACA,gE;AACA,6D;AACA,gB;AACA,E;AACA,uE;AACA,yE;AACA,sE;AACA,0E;AACA,E;AACA,uE;AACA,wE;AACA,8D;AACA,qE;AACA,kE;AACA,uE;AACA,uE;AACA,yE;AACA,qE;AACA,sC;AACA,E;AACA,qE;AACA,8D;AACA,G;;AAEA,yD;AACA,4C;AACA,2B;AACA,2D;;AAEA,+B;AACA,+B;AACA,iC;AACA,E;;AAEA,4D;AACA,iC;AACA,0D;AACA,iD;AACA,c;AACA,iB;AACA,M;AACA,0E;AACA,qC;AACA,E;;AAEA,+C;AACA,kB;AACA,sB;;AAEA,uB;AACA,E;;AAEA,uD;AACA,+B;;AAEA,0E;AACA,iC;AACA,W;;AAEA,2B;AACA,qB;AACA,E;;AAEA,oD;AACA,2C;AACA,E;;;;;;;;;;;;;;;;;;;ACrEA,0C;AACA,G;AACA,iE;AACA,2B;AACA,G;AACA,uE;AACA,uE;AACA,G;AACA,oE;AACA,gE;AACA,iC;AACA,G;AACA,kE;AACA,+D;AACA,8C;AACA,G;AACA,iE;AACA,4D;AACA,G;AACA,iE;AACA,oE;AACA,+D;AACA,qE;AACA,iE;AACA,6C;AACA,G;AACA,2B;AACA,G;AACA,oE;AACA,mE;AACA,mE;AACA,gE;AACA,sE;AACA,oD;AACA,sC;AACA,qC;AACA,2B;AACA,wC;;AAEA,mC;AACA,8B;AACA,kB;AACA,c;AACA,G;AACA,mB;AACA,uB;;AAEA,qB;AACA,kB;AACA,uB;AACA,mB;AACA,mB;AACA,I;;AAEA,yD;AACA,0D;AACA,kD;AACA,yB;AACA,qC;AACA,2B;AACA,0B;AACA,yB;AACA,uB;;AAEA,uB;AACA,E;;AAEA,2D;;AAEA,gD;AACA,0D;AACA,mC;AACA,E;AACA,qD;AACA,oE;AACA,wC;AACA,E;AACA,iD;AACA,4D;AACA,oC;AACA,E;AACA,kD;AACA,8D;AACA,qC;AACA,E;;AAEA,sB;AACA,G;AACA,+D;AACA,6D;AACA,2D;AACA,8D;AACA,gE;AACA,4C;AACA,G;AACA,+D;AACA,iE;AACA,mE;AACA,8C;AACA,G;AACA,6C;AACA,sE;AACA,6D;AACA,yD;AACA,kD;AACA,2D;AACA,kB;;AAEA,qE;AACA,sE;AACA,mE;AACA,qE;AACA,sE;AACA,+C;AACA,I;AACA,qE;AACA,iE;AACA,sE;AACA,iE;AACA,iE;AACA,kE;AACA,0B;AACA,I;AACA,uE;AACA,oE;AACA,qE;AACA,oE;AACA,uE;AACA,0B;AACA,yB;AACA,6F;AACA,G;AACA,wB;AACA,0H;AACA,G;AACA,oB;AACA,6H;AACA,G;;AAEA,gD;AACA,oE;AACA,6B;AACA,O;AACA,K;AACA,8C;;AAEA,W;AACA,E;;AAEA,+C;AACA,2C;AACA,+C;AACA,uC;AACA,0D;AACA,0B;AACA,O;AACA,K;AACA,E;;AAEA,qD;AACA,yC;;AAEA,qB;AACA,wD;AACA,wB;;AAEA,wC;;AAEA,e;;AAEA,oC;AACA,8C;AACA,sD;AACA,sE;AACA,+C;AACA,0D;AACA,wC;AACA,iD;AACA,S;AACA,S;AACA,K;AACA,I;;AAEA,iB;AACA,qE;AACA,8B;AACA,gC;AACA,uC;AACA,8C;AACA,sE;AACA,wB;AACA,yB;AACA,6B;AACA,iC;AACA,8B;;AAEA,iD;AACA,yE;AACA,4D;AACA,wE;AACA,2B;AACA,0D;AACA,qC;AACA,iC;AACA,kB;AACA,gD;AACA,W;AACA,qD;AACA,uC;AACA,2B;AACA,uC;AACA,S;AACA,S;AACA,0B;;AAEA,sE;AACA,mE;AACA,kE;AACA,wD;AACA,qC;AACA,kC;AACA,S;AACA,O;;AAEA,4B;;AAEA,2D;AACA,iE;AACA,sC;AACA,yD;AACA,W;;AAEA,iC;AACA,O;;AAEA,kC;AACA,kC;AACA,0C;AACA,0B;AACA,O;AACA,K;;AAEA,kB;AACA,E;;AAEA,gE;AACA,oE;AACA,gE;AACA,sE;AACA,mE;AACA,iE;AACA,gE;AACA,oE;AACA,Y;AACA,iD;AACA,yC;;AAEA,qB;AACA,wD;AACA,wB;AACA,oC;;AAEA,wC;;AAEA,yB;AACA,wD;AACA,yB;AACA,K;AACA,0B;;AAEA,2C;;AAEA,oB;AACA,mC;AACA,8B;AACA,O;AACA,U;AACA,4B;AACA,G;;AAEA,gB;AACA,E;;AAEA,wB;AACA,yD;AACA,0B;AACA,6B;AACA,4B;AACA,+B;AACA,gC;AACA,mD;;AAEA,+D;AACA,wE;AACA,I;AACA,qC;AACA,gC;AACA,oC;AACA,4D;;AAEA,2D;AACA,gF;AACA,I;AACA,+C;AACA,uE;AACA,yD;AACA,oC;AACA,4D;;AAEA,kE;AACA,8B;AACA,G;AACA,G;;AAEA,6D;AACA,wC;AACA,0C;AACA,+B;AACA,iD;AACA,E;;AAEA,+C;AACA,sD;AACA,mC;AACA,6C;AACA,E;;AAEA,wD;AACA,sD;AACA,mC;AACA,sD;AACA,E;;AAEA,iD;AACA,uB;AACA,W;AACA,0B;;AAEA,0C;;AAEA,4D;AACA,+D;AACA,iE;;AAEA,oB;AACA,mC;AACA,E;;AAEA,qC;AACA,0B;AACA,oD;AACA,E;;AAEA,6D;AACA,+D;AACA,S;AACA,yC;AACA,8B;AACA,4D;AACA,yB;AACA,uB;AACA,U;AACA,uB;AACA,6D;AACA,gC;AACA,G;AACA,E;;AAEA,yB;;AAEA,+C;AACA,kC;AACA,O;AACA,6B;AACA,kB;AACA,a;AACA,gC;AACA,G;AACA,E;;AAEA,iC;AACA,mD;AACA,E;;AAEA,4C;AACA,4B;AACA,4C;AACA,0D;AACA,yC;AACA,E;;AAEA,+C;AACA,sD;;AAEA,W;AACA,sC;AACA,yC;AACA,yC;AACA,sC;AACA,U;AACA,0C;AACA,gF;AACA,mB;AACA,G;AACA,iD;AACA,E;;AAEA,8C;AACA,mC;AACA,yE;AACA,sD;AACA,wD;AACA,E;;AAEA,wD;AACA,mC;AACA,yE;;AAEA,qE;AACA,kC;AACA,0B;AACA,sB;AACA,G;AACA,sD;;AAEA,iB;AACA,yC;AACA,6C;AACA,6C;AACA,+C;AACA,qD;;AAEA,kE;AACA,E;;AAEA,oC;AACA,6C;AACA,gD;AACA,E;;AAEA,wD;AACA,U;AACA,wC;AACA,+B;AACA,wD;AACA,4D;AACA,4D;AACA,qD;AACA,a;AACA,gD;;AAEA,a;AACA,sC;AACA,6B;AACA,wB;AACA,U;AACA,4D;AACA,yB;AACA,gB;AACA,G;AACA,E;;AAEA,gE;AACA,4C;AACA,oC;;AAEA,iC;AACA,2B;;AAEA,sB;AACA,E;;AAEA,6C;AACA,0B;;AAEA,a;AACA,gC;AACA,uB;AACA,G;;AAEA,mB;AACA,E;;AAEA,8C;AACA,8C;AACA,kB;AACA,2B;AACA,gC;AACA,iB;AACA,4B;AACA,kC;AACA,U;AACA,+D;AACA,K;AACA,G;;AAEA,a;AACA,sC;AACA,6B;AACA,wB;AACA,U;AACA,gB;AACA,G;AACA,E;;AAEA,wC;AACA,mD;AACA,gD;AACA,E;;AAEA,qC;AACA,kD;AACA,gD;AACA,E;;AAEA,+D;AACA,0C;AACA,mB;;AAEA,sB;AACA,iD;;AAEA,wE;AACA,+C;AACA,uC;AACA,wE;AACA,yC;AACA,wC;AACA,+B;AACA,iB;;AAEA,sC;AACA,uC;AACA,+C;AACA,uC;AACA,0B;AACA,2D;AACA,0B;AACA,oD;AACA,wC;AACA,4D;AACA,6D;AACA,e;AACA,Y;AACA,+B;AACA,iC;AACA,c;AACA,S;AACA,O;AACA,K;;AAEA,gC;AACA,kC;AACA,e;AACA,O;AACA,uB;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;AC7iBA,6C;AACA,iD;AACA,iB;AACA,iB;AACA,E;;AAEA,2C;AACA,6C;;AAEA,uC;;AAEA,8B;AACA,qC;AACA,sC;AACA,gC;AACA,iC;AACA,0B;AACA,Y;AACA,6B;AACA,K;AACA,K;;AAEA,c;AACA,E;;AAEA,kE;AACA,2C;;AAEA,6D;AACA,+C;AACA,qC;AACA,K;AACA,qC;AACA,8B;AACA,8B;AACA,4D;AACA,+C;AACA,wB;AACA,K;;AAEA,c;AACA,E;;AAEA,gE;AACA,uE;AACA,E;;AAEA,wD;AACA,iD;AACA,wC;AACA,gC;AACA,qC;AACA,kD;AACA,qC;AACA,K;AACA,oB;AACA,K;AACA,gC;AACA,wB;AACA,8B;AACA,6B;AACA,qC;AACA,+B;AACA,0C;;AAEA,kC;AACA,qD;AACA,gE;AACA,oD;AACA,kC;AACA,qC;AACA,4B;;AAEA,+D;AACA,mC;AACA,Q;AACA,2C;AACA,sC;AACA,mE;AACA,8B;;AAEA,0C;AACA,gD;AACA,yC;AACA,sC;AACA,gD;AACA,0C;AACA,a;;AAEA,qE;AACA,sD;AACA,kB;AACA,mE;AACA,W;AACA,W;AACA,Q;AACA,6C;AACA,sC;AACA,8B;AACA,0C;AACA,gD;AACA,yC;AACA,kD;AACA,+D;AACA,yC;AACA,0C;AACA,sC;AACA,4D;AACA,gC;AACA,a;AACA,kB;AACA,sD;AACA,W;AACA,W;AACA,Q;AACA,yD;AACA,sC;AACA,uB;AACA,0C;AACA,gD;AACA,yC;AACA,+D;AACA,kB;AACA,uD;AACA,W;AACA,wC;AACA,W;AACA,Q;AACA,wD;AACA,sC;AACA,0C;AACA,gD;AACA,yC;AACA,6D;AACA,kB;AACA,oD;AACA,+C;AACA,0C;AACA,kD;AACA,W;AACA,W;AACA,O;AACA,O;;AAEA,uD;AACA,iC;AACA,mC;AACA,mD;AACA,K;AACA,K;;AAEA,oC;AACA,4B;AACA,iC;AACA,K;;AAEA,kB;AACA,E;;AAEA,mE;AACA,6D;AACA,2C;;AAEA,iE;AACA,oE;AACA,+D;AACA,+D;AACA,kC;AACA,uC;;AAEA,8B;AACA,8C;AACA,iC;AACA,K;AACA,c;AACA,E;;;;;;;;;;;;;;;;;;;AC/KA,6C;AACA,8B;AACA,a;AACA,sB;AACA,sC;AACA,I;AACA,E;;AAEA,kD;AACA,gC;AACA,wB;AACA,wC;AACA,uB;AACA,kB;AACA,sC;AACA,M;AACA,G;AACA,W;AACA,E;;AAEA,+B;AACA,4D;AACA,E;;AAEA,2C;AACA,uD;AACA,sD;AACA,uD;AACA,qC;AACA,+B;AACA,E;AACA,sD;AACA,mD;AACA,0C;AACA,yD;AACA,+B;AACA,qD;;AAEA,yB;AACA,mE;AACA,0C;AACA,8B;AACA,uE;;AAEA,yE;;AAEA,8C;AACA,qE;AACA,2D;AACA,qC;AACA,uC;AACA,8E;AACA,U;AACA,wB;AACA,sD;AACA,wC;AACA,qD;AACA,qD;AACA,O;AACA,yD;AACA,qD;AACA,O;AACA,iB;AACA,oB;AACA,yB;AACA,oC;AACA,iC;AACA,2D;AACA,S;AACA,iB;AACA,O;AACA,sC;AACA,M;AACA,G;AACA,c;AACA,E;;AAEA,kC;AACA,6C;AACA,yD;AACA,6C;AACA,iD;AACA,mD;AACA,G;;AAEA,gB;AACA,gB;AACA,uB;AACA,yD;AACA,+B;AACA,E;;;AAGA,uD;AACA,4C;AACA,E","sourcesContent":["Blaze = {};\n","var debugFunc;\n\n// We call into user code in many places, and it's nice to catch exceptions\n// propagated from user code immediately so that the whole system doesn't just\n// break.  Catching exceptions is easy; reporting them is hard.  This helper\n// reports exceptions.\n//\n// Usage:\n//\n// ```\n// try {\n//   // ... someStuff ...\n// } catch (e) {\n//   reportUIException(e);\n// }\n// ```\n//\n// An optional second argument overrides the default message.\n\n// Set this to `true` to cause `reportException` to throw\n// the next exception rather than reporting it.  This is\n// useful in unit tests that test error messages.\nBlaze._throwNextException = false;\n\nBlaze.reportException = function (e, msg) {\n  if (Blaze._throwNextException) {\n    Blaze._throwNextException = false;\n    throw e;\n  }\n\n  if (! debugFunc)\n    // adapted from Deps\n    debugFunc = function () {\n      return (typeof Meteor !== \"undefined\" ? Meteor._debug :\n              ((typeof console !== \"undefined\") && console.log ? console.log :\n               function () {}));\n    };\n\n  // In Chrome, `e.stack` is a multiline string that starts with the message\n  // and contains a stack trace.  Furthermore, `console.log` makes it clickable.\n  // `console.log` supplies the space between the two arguments.\n  debugFunc()(msg || 'Exception caught in template:', e.stack || e.message);\n};\n\nBlaze.wrapCatchingExceptions = function (f, where) {\n  if (typeof f !== 'function')\n    return f;\n\n  return function () {\n    try {\n      return f.apply(this, arguments);\n    } catch (e) {\n      Blaze.reportException(e, 'Exception in ' + where + ':');\n    }\n  };\n};\n","/**\n * ## [new] Blaze.ReactiveVar(initialValue, [equalsFunc])\n *\n * A ReactiveVar holds a single value that can be get and set,\n * such that calling `set` will invalidate any Computations that\n * called `get`, according to the usual contract for reactive\n * data sources.\n *\n * A ReactiveVar is much like a Session variable -- compare `foo.get()`\n * to `Session.get(\"foo\")` -- but it doesn't have a global name and isn't\n * automatically migrated across hot code pushes.  Also, while Session\n * variables can only hold JSON or EJSON, ReactiveVars can hold any value.\n *\n * An important property of ReactiveVars, which is sometimes the reason\n * to use one, is that setting the value to the same value as before has\n * no effect, meaning ReactiveVars can be used to absorb extra\n * invalidations that wouldn't serve a purpose.  However, by default,\n * ReactiveVars are extremely conservative about what changes they\n * absorb.  Calling `set` with an object argument will *always* trigger\n * invalidations, because even if the new value is `===` the old value,\n * the object may have been mutated.  You can change the default behavior\n * by passing a function of two arguments, `oldValue` and `newValue`,\n * to the constructor as `equalsFunc`.\n *\n * This class is extremely basic right now, but the idea is to evolve\n * it into the ReactiveVar of Geoff's Lickable Forms proposal.\n */\n\nBlaze.ReactiveVar = function (initialValue, equalsFunc) {\n  if (! (this instanceof Blaze.ReactiveVar))\n    // called without `new`\n    return new Blaze.ReactiveVar(initialValue, equalsFunc);\n\n  this.curValue = initialValue;\n  this.equalsFunc = equalsFunc;\n  this.dep = new Deps.Dependency;\n};\n\nBlaze.ReactiveVar._isEqual = function (oldValue, newValue) {\n  var a = oldValue, b = newValue;\n  // Two values are \"equal\" here if they are `===` and are\n  // number, boolean, string, undefined, or null.\n  if (a !== b)\n    return false;\n  else\n    return ((!a) || (typeof a === 'number') || (typeof a === 'boolean') ||\n            (typeof a === 'string'));\n};\n\nBlaze.ReactiveVar.prototype.get = function () {\n  if (Deps.active)\n    this.dep.depend();\n\n  return this.curValue;\n};\n\nBlaze.ReactiveVar.prototype.set = function (newValue) {\n  var oldValue = this.curValue;\n\n  if ((this.equalsFunc || Blaze.ReactiveVar._isEqual)(oldValue, newValue))\n    // value is same as last time\n    return;\n\n  this.curValue = newValue;\n  this.dep.changed();\n};\n\nBlaze.ReactiveVar.prototype.toString = function () {\n  return 'ReactiveVar{' + this.get() + '}';\n};\n","/// [new] Blaze.View([kind], renderMethod)\n///\n/// Blaze.View is the building block of reactive DOM.  Views have\n/// the following features:\n///\n/// * lifecycle callbacks - Views are created, rendered, and destroyed,\n///   and callbacks can be registered to fire when these things happen.\n///\n/// * parent pointer - A View points to its parentView, which is the\n///   View that caused it to be rendered.  These pointers form a\n///   hierarchy or tree of Views.\n///\n/// * render() method - A View's render() method specifies the DOM\n///   (or HTML) content of the View.  If the method establishes\n///   reactive dependencies, it may be re-run.\n///\n/// * a DOMRange - If a View is rendered to DOM, its position and\n///   extent in the DOM are tracked using a DOMRange object.\n///\n/// When a View is constructed by calling Blaze.View, the View is\n/// not yet considered \"created.\"  It doesn't have a parentView yet,\n/// and no logic has been run to initialize the View.  All real\n/// work is deferred until at least creation time, when the onCreated\n/// callbacks are fired, which happens when the View is \"used\" in\n/// some way that requires it to be rendered.\n///\n/// ...more lifecycle stuff\n///\n/// `kind` is an optional string tag identifying the View.  The only\n/// time it's used is when looking in the View tree for a View of a\n/// particular kind; for example, data contexts are stored on Views\n/// of kind \"with\".  Kinds are also useful when debugging, so in\n/// general it's good for functions that create Views to set the kind.\n/// Templates have kinds of the form \"Template.foo\".\nBlaze.View = function (kind, render) {\n  if (! (this instanceof Blaze.View))\n    // called without `new`\n    return new Blaze.View(kind, render);\n\n  if (typeof kind === 'function') {\n    // omitted \"kind\" argument\n    render = kind;\n    kind = '';\n  }\n  this.kind = kind;\n  this.render = render;\n\n  this._callbacks = {\n    created: null,\n    materialized: null,\n    rendered: null,\n    destroyed: null\n  };\n\n  // Setting all properties here is good for readability,\n  // and also may help Chrome optimize the code by keeping\n  // the View object from changing shape too much.\n  this.isCreated = false;\n  this.isCreatedForExpansion = false;\n  this.isDestroyed = false;\n  this.isInRender = false;\n  this.parentView = null;\n  this.domrange = null;\n\n  this.renderCount = 0;\n};\n\nBlaze.View.prototype.render = function () { return null; };\n\nBlaze.View.prototype.onCreated = function (cb) {\n  this._callbacks.created = this._callbacks.created || [];\n  this._callbacks.created.push(cb);\n};\nBlaze.View.prototype.onMaterialized = function (cb) {\n  this._callbacks.materialized = this._callbacks.materialized || [];\n  this._callbacks.materialized.push(cb);\n};\nBlaze.View.prototype.onRendered = function (cb) {\n  this._callbacks.rendered = this._callbacks.rendered || [];\n  this._callbacks.rendered.push(cb);\n};\nBlaze.View.prototype.onDestroyed = function (cb) {\n  this._callbacks.destroyed = this._callbacks.destroyed || [];\n  this._callbacks.destroyed.push(cb);\n};\n\n/// View#autorun(func)\n///\n/// Sets up a Deps autorun that is \"scoped\" to this View in two\n/// important ways: 1) Blaze.currentView is automatically set\n/// on every re-run, and 2) the autorun is stopped when the\n/// View is destroyed.  As with Deps.autorun, the first run of\n/// the function is immediate, and a Computation object that can\n/// be used to stop the autorun is returned.\n///\n/// View#autorun is meant to be called from View callbacks like\n/// onCreated, or from outside the rendering process.  It may not\n/// be called before the onCreated callbacks are fired (too early),\n/// or from a render() method (too confusing).\n///\n/// Typically, autoruns that update the state\n/// of the View (as in Blaze.With) should be started from an onCreated\n/// callback.  Autoruns that update the DOM should be started\n/// from either onCreated (guarded against the absence of\n/// view.domrange), onMaterialized, or onRendered.\nBlaze.View.prototype.autorun = function (f, _inViewScope) {\n  var self = this;\n\n  // The restrictions on when View#autorun can be called are in order\n  // to avoid bad patterns, like creating a Blaze.View and immediately\n  // calling autorun on it.  A freshly created View is not ready to\n  // have logic run on it; it doesn't have a parentView, for example.\n  // It's when the View is materialized or expanded that the onCreated\n  // handlers are fired and the View starts up.\n  //\n  // Letting the render() method call `this.autorun()` is problematic\n  // because of re-render.  The best we can do is to stop the old\n  // autorun and start a new one for each render, but that's a pattern\n  // we try to avoid internally because it leads to helpers being\n  // called extra times, in the case where the autorun causes the\n  // view to re-render (and thus the autorun to be torn down and a\n  // new one established).\n  //\n  // We could lift these restrictions in various ways.  One interesting\n  // idea is to allow you to call `view.autorun` after instantiating\n  // `view`, and automatically wrap it in `view.onCreated`, deferring\n  // the autorun so that it starts at an appropriate time.  However,\n  // then we can't return the Computation object to the caller, because\n  // it doesn't exist yet.\n  if (! self.isCreated) {\n    throw new Error(\"View#autorun must be called from the created callback at the earliest\");\n  }\n  if (this.isInRender) {\n    throw new Error(\"Can't call View#autorun from inside render(); try calling it from the created or rendered callback\");\n  }\n  if (Deps.active) {\n    throw new Error(\"Can't call View#autorun from a Deps Computation; try calling it from the created or rendered callback\");\n  }\n\n  var c = Deps.autorun(function viewAutorun(c) {\n    return Blaze.withCurrentView(_inViewScope || self, function () {\n      return f.call(self, c);\n    });\n  });\n  self.onDestroyed(function () { c.stop(); });\n\n  return c;\n};\n\nBlaze._fireCallbacks = function (view, which) {\n  Blaze.withCurrentView(view, function () {\n    Deps.nonreactive(function fireCallbacks() {\n      var cbs = view._callbacks[which];\n      for (var i = 0, N = (cbs && cbs.length); i < N; i++)\n        cbs[i].call(view);\n    });\n  });\n};\n\nBlaze.materializeView = function (view, parentView) {\n  view.parentView = (parentView || null);\n\n  if (view.isCreated)\n    throw new Error(\"Can't render the same View twice\");\n  view.isCreated = true;\n\n  Blaze._fireCallbacks(view, 'created');\n\n  var domrange;\n\n  var needsRenderedCallback = false;\n  var scheduleRenderedCallback = function () {\n    if (needsRenderedCallback && ! view.isDestroyed &&\n        view._callbacks.rendered && view._callbacks.rendered.length) {\n      Deps.afterFlush(function callRendered() {\n        if (needsRenderedCallback && ! view.isDestroyed) {\n          needsRenderedCallback = false;\n          Blaze._fireCallbacks(view, 'rendered');\n        }\n      });\n    }\n  };\n\n  var lastHtmljs;\n  // We don't expect to be called in a Computation, but just in case,\n  // wrap in Deps.nonreactive.\n  Deps.nonreactive(function () {\n    view.autorun(function doRender(c) {\n      // `view.autorun` sets the current view.\n      // Any dependencies that should invalidate this Computation come\n      // from this line:\n      view.renderCount++;\n      view.isInRender = true;\n      var htmljs = view.render();\n      view.isInRender = false;\n\n      Deps.nonreactive(function doMaterialize() {\n        var materializer = new Blaze.DOMMaterializer({parentView: view});\n        var rangesAndNodes = materializer.visit(htmljs, []);\n        if (c.firstRun || ! Blaze._isContentEqual(lastHtmljs, htmljs)) {\n          if (c.firstRun) {\n            domrange = new Blaze.DOMRange(rangesAndNodes);\n            view.domrange = domrange;\n            domrange.view = view;\n          } else {\n            domrange.setMembers(rangesAndNodes);\n          }\n          Blaze._fireCallbacks(view, 'materialized');\n          needsRenderedCallback = true;\n          if (! c.firstRun)\n            scheduleRenderedCallback();\n        }\n      });\n      lastHtmljs = htmljs;\n\n      // Causes any nested views to stop immediately, not when we call\n      // `setMembers` the next time around the autorun.  Otherwise,\n      // helpers in the DOM tree to be replaced might be scheduled\n      // to re-run before we have a chance to stop them.\n      Deps.onInvalidate(function () {\n        domrange.destroyMembers();\n      });\n    });\n\n    var teardownHook = null;\n\n    domrange.onAttached(function attached(range, element) {\n      teardownHook = Blaze.DOMBackend.Teardown.onElementTeardown(\n        element, function teardown() {\n          Blaze.destroyView(view, true /* _skipNodes */);\n        });\n\n      scheduleRenderedCallback();\n    });\n\n    // tear down the teardown hook\n    view.onDestroyed(function () {\n      teardownHook && teardownHook.stop();\n      teardownHook = null;\n    });\n  });\n\n  return domrange;\n};\n\n// Expands a View to HTMLjs, calling `render` recursively on all\n// Views and evaluating any dynamic attributes.  Calls the `created`\n// callback, but not the `materialized` or `rendered` callbacks.\n// Destroys the view immediately, unless called in a Deps Computation,\n// in which case the view will be destroyed when the Computation is\n// invalidated.  If called in a Deps Computation, the result is a\n// reactive string; that is, the Computation will be invalidated\n// if any changes are made to the view or subviews that might affect\n// the HTML.\nBlaze._expandView = function (view, parentView) {\n  view.parentView = (parentView || null);\n\n  if (view.isCreated)\n    throw new Error(\"Can't render the same View twice\");\n  view.isCreated = true;\n  view.isCreatedForExpansion = true;\n\n  Blaze._fireCallbacks(view, 'created');\n\n  view.isInRender = true;\n  var htmljs = Blaze.withCurrentView(view, function () {\n    return view.render();\n  });\n  view.isInRender = false;\n\n  var result = Blaze._expand(htmljs, view);\n\n  if (Deps.active) {\n    Deps.onInvalidate(function () {\n      Blaze.destroyView(view);\n    });\n  } else {\n    Blaze.destroyView(view);\n  }\n\n  return result;\n};\n\n// Options: `parentView`\nBlaze.HTMLJSExpander = HTML.TransformingVisitor.extend();\nBlaze.HTMLJSExpander.def({\n  visitObject: function (x) {\n    if (Blaze.isTemplate(x))\n      x = Blaze.runTemplate(x);\n    if (x instanceof Blaze.View)\n      return Blaze._expandView(x, this.parentView);\n\n    // this will throw an error; other objects are not allowed!\n    return HTML.TransformingVisitor.prototype.visitObject.call(this, x);\n  },\n  visitAttributes: function (attrs) {\n    // expand dynamic attributes\n    if (typeof attrs === 'function')\n      attrs = Blaze.withCurrentView(this.parentView, attrs);\n\n    // call super (e.g. for case where `attrs` is an array)\n    return HTML.TransformingVisitor.prototype.visitAttributes.call(this, attrs);\n  },\n  visitAttribute: function (name, value, tag) {\n    // expand attribute values that are functions.  Any attribute value\n    // that contains Views must be wrapped in a function.\n    if (typeof value === 'function')\n      value = Blaze.withCurrentView(this.parentView, value);\n\n    return HTML.TransformingVisitor.prototype.visitAttribute.call(\n      this, name, value, tag);\n  }\n});\n\n// Return Blaze.currentView, but only if it is being rendered\n// (i.e. we are in its render() method).\nvar currentViewIfRendering = function () {\n  var view = Blaze.currentView;\n  return (view && view.isInRender) ? view : null;\n};\n\nBlaze._expand = function (htmljs, parentView) {\n  parentView = parentView || currentViewIfRendering();\n  return (new Blaze.HTMLJSExpander(\n    {parentView: parentView})).visit(htmljs);\n};\n\nBlaze._expandAttributes = function (attrs, parentView) {\n  parentView = parentView || currentViewIfRendering();\n  return (new Blaze.HTMLJSExpander(\n    {parentView: parentView})).visitAttributes(attrs);\n};\n\nBlaze.destroyView = function (view, _skipNodes) {\n  if (view.isDestroyed)\n    return;\n  view.isDestroyed = true;\n\n  Blaze._fireCallbacks(view, 'destroyed');\n\n  // Destroy views and elements recursively.  If _skipNodes,\n  // only recurse up to views, not elements, for the case where\n  // the backend (jQuery) is recursing over the elements already.\n\n  if (view.domrange)\n    view.domrange.destroyMembers();\n};\n\nBlaze.destroyNode = function (node) {\n  if (node.nodeType === 1)\n    Blaze.DOMBackend.Teardown.tearDownElement(node);\n};\n\n// Are the HTMLjs entities `a` and `b` the same?  We could be\n// more elaborate here but the point is to catch the most basic\n// cases.\nBlaze._isContentEqual = function (a, b) {\n  if (a instanceof HTML.Raw) {\n    return (b instanceof HTML.Raw) && (a.value === b.value);\n  } else if (a == null) {\n    return (b == null);\n  } else {\n    return (a === b) &&\n      ((typeof a === 'number') || (typeof a === 'boolean') ||\n       (typeof a === 'string'));\n  }\n};\n\nBlaze.currentView = null;\n\nBlaze.withCurrentView = function (view, func) {\n  var oldView = Blaze.currentView;\n  try {\n    Blaze.currentView = view;\n    return func();\n  } finally {\n    Blaze.currentView = oldView;\n  }\n};\n\nBlaze.isTemplate = function (t) {\n  return t && (typeof t.__makeView === 'function');\n};\n\nBlaze.runTemplate = function (t/*, args*/) {\n  if (! Blaze.isTemplate(t))\n    throw new Error(\"Not a template: \" + t);\n  var restArgs = Array.prototype.slice.call(arguments, 1);\n  return t.__makeView.apply(t, restArgs);\n};\n\nBlaze.render = function (content, parentView) {\n  parentView = parentView || currentViewIfRendering();\n\n  var view;\n  if (typeof content === 'function') {\n    view = Blaze.View('render', content);\n  } else if (Blaze.isTemplate(content)) {\n    view = Blaze.runTemplate(content);\n  } else {\n    if (! (content instanceof Blaze.View))\n      throw new Error(\"Expected a function, template, or View in Blaze.render\");\n    view = content;\n  }\n  return Blaze.materializeView(view, parentView);\n};\n\nBlaze.toHTML = function (htmljs, parentView) {\n  if (typeof htmljs === 'function')\n    throw new Error(\"Blaze.toHTML doesn't take a function, just HTMLjs\");\n  parentView = parentView || currentViewIfRendering();\n  return HTML.toHTML(Blaze._expand(htmljs, parentView));\n};\n\nBlaze.toText = function (htmljs, parentView, textMode) {\n  if (typeof htmljs === 'function')\n    throw new Error(\"Blaze.toText doesn't take a function, just HTMLjs\");\n\n  if ((parentView != null) && ! (parentView instanceof Blaze.View)) {\n    // omitted parentView argument\n    textMode = parentView;\n    parentView = null;\n  }\n  parentView = parentView || currentViewIfRendering();\n\n  if (! textMode)\n    throw new Error(\"textMode required\");\n  if (! (textMode === HTML.TEXTMODE.STRING ||\n         textMode === HTML.TEXTMODE.RCDATA ||\n         textMode === HTML.TEXTMODE.ATTRIBUTE))\n    throw new Error(\"Unknown textMode: \" + textMode);\n\n  return HTML.toText(Blaze._expand(htmljs, parentView), textMode);\n};\n\nBlaze.getCurrentData = function () {\n  var theWith = Blaze.getCurrentView('with');\n  return theWith ? theWith.dataVar.get() : null;\n};\n\n// Gets the current view or its nearest ancestor of kind\n// `kind`.\nBlaze.getCurrentView = function (kind) {\n  var view = Blaze.currentView;\n  // Better to fail in cases where it doesn't make sense\n  // to use Blaze.getCurrentView().  There will be a current\n  // view anywhere it does.  You can check Blaze.currentView\n  // if you want to know whether there is one or not.\n  if (! view)\n    throw new Error(\"There is no current view\");\n\n  if (kind) {\n    while (view && view.kind !== kind)\n      view = view.parentView;\n    return view || null;\n  } else {\n    // Blaze.getCurrentView() with no arguments just returns\n    // Blaze.currentView.\n    return view;\n  }\n};\n\n// Gets the nearest ancestor view that corresponds to a template\nBlaze.getCurrentTemplateView = function () {\n  var view = Blaze.getCurrentView();\n\n  while (view && ! view.template)\n    view = view.parentView;\n\n  return view || null;\n};\n\nBlaze.getParentView = function (view, kind) {\n  var v = view.parentView;\n\n  if (kind) {\n    while (v && v.kind !== kind)\n      v = v.parentView;\n  }\n\n  return v || null;\n};\n\nBlaze.getElementView = function (elem, kind) {\n  var range = Blaze.DOMRange.forElement(elem);\n  var view = null;\n  while (range && ! view) {\n    view = (range.view || null);\n    if (! view) {\n      if (range.parentRange)\n        range = range.parentRange;\n      else\n        range = Blaze.DOMRange.forElement(range.parentElement);\n    }\n  }\n\n  if (kind) {\n    while (view && view.kind !== kind)\n      view = view.parentView;\n    return view || null;\n  } else {\n    return view;\n  }\n};\n\nBlaze.getElementData = function (elem) {\n  var theWith = Blaze.getElementView(elem, 'with');\n  return theWith ? theWith.dataVar.get() : null;\n};\n\nBlaze.getViewData = function (view) {\n  var theWith = Blaze.getParentView(view, 'with');\n  return theWith ? theWith.dataVar.get() : null;\n};\n\nBlaze._addEventMap = function (view, eventMap, thisInHandler) {\n  thisInHandler = (thisInHandler || null);\n  var handles = [];\n\n  if (! view.domrange)\n    throw new Error(\"View must have a DOMRange\");\n\n  view.domrange.onAttached(function attached_eventMaps(range, element) {\n    _.each(eventMap, function (handler, spec) {\n      var clauses = spec.split(/,\\s+/);\n      // iterate over clauses of spec, e.g. ['click .foo', 'click .bar']\n      _.each(clauses, function (clause) {\n        var parts = clause.split(/\\s+/);\n        if (parts.length === 0)\n          return;\n\n        var newEvents = parts.shift();\n        var selector = parts.join(' ');\n        handles.push(Blaze.EventSupport.listen(\n          element, newEvents, selector,\n          function (evt) {\n            if (! range.containsElement(evt.currentTarget))\n              return null;\n            var handlerThis = thisInHandler || this;\n            var handlerArgs = arguments;\n            return Blaze.withCurrentView(view, function () {\n              return handler.apply(handlerThis, handlerArgs);\n            });\n          },\n          range, function (r) {\n            return r.parentRange;\n          }));\n      });\n    });\n  });\n\n  view.onDestroyed(function () {\n    _.each(handles, function (h) {\n      h.stop();\n    });\n    handles.length = 0;\n  });\n};\n","Blaze._calculateCondition = function (cond) {\n  if (cond instanceof Array && cond.length === 0)\n    cond = false;\n  return !! cond;\n};\n\nBlaze.With = function (data, contentFunc) {\n  var view = Blaze.View('with', contentFunc);\n\n  view.dataVar = new Blaze.ReactiveVar;\n\n  view.onCreated(function () {\n    if (typeof data === 'function') {\n      // `data` is a reactive function\n      view.autorun(function () {\n        view.dataVar.set(data());\n      }, view.parentView);\n    } else {\n      view.dataVar.set(data);\n    }\n  });\n\n  return view;\n};\n\nBlaze.If = function (conditionFunc, contentFunc, elseFunc, _not) {\n  var conditionVar = new Blaze.ReactiveVar;\n\n  var view = Blaze.View(_not ? 'unless' : 'if', function () {\n    return conditionVar.get() ? contentFunc() :\n      (elseFunc ? elseFunc() : null);\n  });\n  view.__conditionVar = conditionVar;\n  view.onCreated(function () {\n    this.autorun(function () {\n      var cond = Blaze._calculateCondition(conditionFunc());\n      conditionVar.set(_not ? (! cond) : cond);\n    }, this.parentView);\n  });\n\n  return view;\n};\n\nBlaze.Unless = function (conditionFunc, contentFunc, elseFunc) {\n  return Blaze.If(conditionFunc, contentFunc, elseFunc, true /*_not*/);\n};\n\nBlaze.Each = function (argFunc, contentFunc, elseFunc) {\n  var eachView = Blaze.View('each', function () {\n    var subviews = this.initialSubviews;\n    this.initialSubviews = null;\n    if (this.isCreatedForExpansion) {\n      this.expandedValueDep = new Deps.Dependency;\n      this.expandedValueDep.depend();\n    }\n    return subviews;\n  });\n  eachView.initialSubviews = [];\n  eachView.numItems = 0;\n  eachView.inElseMode = false;\n  eachView.stopHandle = null;\n  eachView.contentFunc = contentFunc;\n  eachView.elseFunc = elseFunc;\n  eachView.argVar = new Blaze.ReactiveVar;\n\n  eachView.onCreated(function () {\n    // We evaluate argFunc in an autorun to make sure\n    // Blaze.currentView is always set when it runs (rather than\n    // passing argFunc straight to ObserveSequence).\n    eachView.autorun(function () {\n      eachView.argVar.set(argFunc());\n    }, eachView.parentView);\n\n    eachView.stopHandle = ObserveSequence.observe(function () {\n      return eachView.argVar.get();\n    }, {\n      addedAt: function (id, item, index) {\n        Deps.nonreactive(function () {\n          var newItemView = Blaze.With(item, eachView.contentFunc);\n          eachView.numItems++;\n\n          if (eachView.expandedValueDep) {\n            eachView.expandedValueDep.changed();\n          } else if (eachView.domrange) {\n            if (eachView.inElseMode) {\n              eachView.domrange.removeMember(0);\n              eachView.inElseMode = false;\n            }\n\n            var range = Blaze.materializeView(newItemView, eachView);\n            eachView.domrange.addMember(range, index);\n          } else {\n            eachView.initialSubviews.splice(index, 0, newItemView);\n          }\n        });\n      },\n      removedAt: function (id, item, index) {\n        Deps.nonreactive(function () {\n          eachView.numItems--;\n          if (eachView.expandedValueDep) {\n            eachView.expandedValueDep.changed();\n          } else if (eachView.domrange) {\n            eachView.domrange.removeMember(index);\n            if (eachView.elseFunc && eachView.numItems === 0) {\n              eachView.inElseMode = true;\n              eachView.domrange.addMember(\n                Blaze.materializeView(\n                  Blaze.View('each_else',eachView.elseFunc),\n                  eachView), 0);\n            }\n          } else {\n            eachView.initialSubviews.splice(index, 1);\n          }\n        });\n      },\n      changedAt: function (id, newItem, oldItem, index) {\n        Deps.nonreactive(function () {\n          var itemView;\n          if (eachView.expandedValueDep) {\n            eachView.expandedValueDep.changed();\n          } else if (eachView.domrange) {\n            itemView = eachView.domrange.getMember(index).view;\n          } else {\n            itemView = eachView.initialSubviews[index];\n          }\n          itemView.dataVar.set(newItem);\n        });\n      },\n      movedTo: function (id, item, fromIndex, toIndex) {\n        Deps.nonreactive(function () {\n          if (eachView.expandedValueDep) {\n            eachView.expandedValueDep.changed();\n          } else if (eachView.domrange) {\n            eachView.domrange.moveMember(fromIndex, toIndex);\n          } else {\n            var subviews = eachView.initialSubviews;\n            var itemView = subviews[fromIndex];\n            subviews.splice(fromIndex, 1);\n            subviews.splice(toIndex, 0, itemView);\n          }\n        });\n      }\n    });\n\n    if (eachView.elseFunc && eachView.numItems === 0) {\n      eachView.inElseMode = true;\n      eachView.initialSubviews[0] =\n        Blaze.View('each_else', eachView.elseFunc);\n    }\n  });\n\n  eachView.onDestroyed(function () {\n    if (eachView.stopHandle)\n      eachView.stopHandle.stop();\n  });\n\n  return eachView;\n};\n\nBlaze.InOuterTemplateScope = function (templateView, contentFunc) {\n  var view = Blaze.View('InOuterTemplateScope', contentFunc);\n  var parentView = templateView.parentView;\n\n  // Hack so that if you call `{{> foo bar}}` and it expands into\n  // `{{#with bar}}{{> foo}}{{/with}}`, and then `foo` is a template\n  // that inserts `{{> UI.contentBlock}}`, the data context for\n  // `UI.contentBlock` is not `bar` but the one enclosing that.\n  if (parentView.__isTemplateWith)\n    parentView = parentView.parentView;\n\n  view.onCreated(function () {\n    this.originalParentView = this.parentView;\n    this.parentView = parentView;\n  });\n  return view;\n};\n","var bindIfIsFunction = function (x, target) {\n  if (typeof x !== 'function')\n    return x;\n  return function () {\n    return x.apply(target, arguments);\n  };\n};\n\nvar bindToCurrentDataIfIsFunction = function (x) {\n  if (typeof x === 'function') {\n    return function () {\n      var data = Blaze.getCurrentData();\n      if (data == null)\n        data = {};\n      return x.apply(data, arguments);\n    };\n  }\n  return x;\n};\n\nvar wrapHelper = function (f) {\n  return Blaze.wrapCatchingExceptions(f, 'template helper');\n};\n\n// Implements {{foo}} where `name` is \"foo\"\n// and `component` is the component the tag is found in\n// (the lexical \"self,\" on which to look for methods).\n// If a function is found, it is bound to the object it\n// was found on.  Returns a function,\n// non-function value, or null.\n//\n// NOTE: This function must not establish any reactive\n// dependencies.  If there is any reactivity in the\n// value, lookup should return a function.\nBlaze.View.prototype.lookup = function (name, _options) {\n  var template = this.template;\n  var lookupTemplate = _options && _options.template;\n\n  if (/^\\./.test(name)) {\n    // starts with a dot. must be a series of dots which maps to an\n    // ancestor of the appropriate height.\n    if (!/^(\\.)+$/.test(name))\n      throw new Error(\"id starting with dot must be a series of dots\");\n\n    return Blaze._parentData(name.length - 1, true /*_functionWrapped*/);\n\n  } else if (template && (name in template)) {\n    return wrapHelper(bindToCurrentDataIfIsFunction(template[name]));\n  } else if (lookupTemplate && Template.__lookup__(name)) {\n    return Template.__lookup__(name);\n  } else if (UI._globalHelpers[name]) {\n    return wrapHelper(bindToCurrentDataIfIsFunction(UI._globalHelpers[name]));\n  } else {\n    return function () {\n      var isCalledAsFunction = (arguments.length > 0);\n      var data = Blaze.getCurrentData();\n      if (lookupTemplate && ! (data && data[name])) {\n        throw new Error(\"No such template: \" + name);\n      }\n      if (isCalledAsFunction && ! (data && data[name])) {\n        throw new Error(\"No such function: \" + name);\n      }\n      if (! data)\n        return null;\n      var x = data[name];\n      if (typeof x !== 'function') {\n        if (isCalledAsFunction) {\n          throw new Error(\"Can't call non-function: \" + x);\n        }\n        return x;\n      }\n      return x.apply(data, arguments);\n    };\n  }\n  return null;\n};\n\n// Implement Spacebars' {{../..}}.\n// @param height {Number} The number of '..'s\nBlaze._parentData = function (height, _functionWrapped) {\n  var theWith = Blaze.getCurrentView('with');\n  for (var i = 0; (i < height) && theWith; i++) {\n    theWith = Blaze.getParentView(theWith, 'with');\n  }\n\n  if (! theWith)\n    return null;\n  if (_functionWrapped)\n    return function () { return theWith.dataVar.get(); };\n  return theWith.dataVar.get();\n};\n\n\nBlaze.View.prototype.lookupTemplate = function (name) {\n  return this.lookup(name, {template:true});\n};\n"]}